// Generated by Haxe
(function ($hx_exports) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); };
var EReg = function(r,opt) {
	opt = opt.split("u").join("");
	this.r = new RegExp(r,opt);
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) this.r.lastIndex = 0;
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) return undefined;
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) len = s.length; else if(len < 0) {
		if(pos == 0) len = s.length + len; else return "";
	}
	return s.substr(pos,len);
};
var Main = function() { };
Main.__name__ = true;
Main.main = $hx_exports["activate"] = function(context) {
	Main.test_register_command(context);
	var server = new CompletionServer(Vscode.workspace.rootPath);
	var handler = new CompletionHandler(server,context);
	context.subscriptions.push({ dispose : function() {
		Vscode.window.showInformationMessage("Got dispose!");
	}});
};
Main.test_register_command = function(context) {
	var disposable = Vscode.commands.registerCommand("haxe.hello",function() {
		Vscode.window.showInformationMessage("Hello from haxe!");
	});
	context.subscriptions.push(disposable);
};
Main.test_register_hover = function(context) {
	var disposable = Vscode.languages.registerHoverProvider("haxe",{ provideHover : function(document,position,cancelToken) {
		return new Vscode.Hover("I am a hover! pos: " + JSON.stringify(position));
	}});
	context.subscriptions.push(disposable);
};
Main.test_register_hover_thenable = function(context) {
	var disposable = Vscode.languages.registerHoverProvider("haxe",{ provideHover : function(document,position,cancelToken) {
		var s = JSON.stringify(position);
		return new Promise(function(resolve) {
			var h = new Vscode.Hover("I am a thenable hover! pos: " + s);
			resolve(h);
		});
	}});
	context.subscriptions.push(disposable);
};
var CompletionItemProvider = function() { };
CompletionItemProvider.__name__ = true;
var CompletionHandler = function(server,context) {
	this.server = server;
	var disposable = Vscode.languages.registerCompletionItemProvider("haxe",this,".");
	context.subscriptions.push(disposable);
	var removePatch = function(document) {
		if(server.isPatchAvailable) {
			var path = document.uri.fsPath;
			var client = server.client;
			client.cmdLine.beginPatch(path).remove();
			client.sendAll(null);
		}
	};
	context.subscriptions.push(Vscode.workspace.onDidOpenTextDocument(removePatch));
	context.subscriptions.push(Vscode.workspace.onDidSaveTextDocument(removePatch));
	context.subscriptions.push(Vscode.workspace.onDidCloseTextDocument(removePatch));
	var changePatch = function(event) {
		if(!server.isServerAvailable) {
			var changes = event.contentChanges;
			if(changes.length > 0) {
				var document1 = event.document;
				var client1 = server.client;
				var patcher = client1.cmdLine.beginPatch(document1.uri.fsPath);
				if(document1.isDirty) patcher["delete"](0,-1).insert(0,document1.getText()); else patcher.remove();
				client1.sendAll(null);
			}
		} else if(server.isPatchAvailable) {
			var changes1 = event.contentChanges;
			if(changes1.length > 0) {
				var document2 = event.document;
				var client2 = server.client;
				var patcher1 = client2.cmdLine.beginPatch(document2.uri.fsPath);
				var _g = 0;
				while(_g < changes1.length) {
					var change = changes1[_g];
					++_g;
					var rl = change.rangeLength;
					var range = change.range;
					var rs = document2.offsetAt(range.start);
					if(change.rangeLength > 0) patcher1["delete"](rs,rl,"c");
					var text = change.text;
					if(text != "") patcher1.insert(rs,text,"c");
				}
				client2.sendAll(null);
			}
		}
	};
	context.subscriptions.push(Vscode.workspace.onDidChangeTextDocument(changePatch));
};
CompletionHandler.__name__ = true;
CompletionHandler.__interfaces__ = [CompletionItemProvider];
CompletionHandler.prototype = {
	provideCompletionItems: function(document,position,cancelToken) {
		var _g = this;
		var line = document.lineAt(position);
		var dot_offset = 0;
		var byte_pos = document.offsetAt(position) + dot_offset;
		byte_pos = Tool.byteLength((function($this) {
			var $r;
			var _this = document.getText();
			$r = HxOverrides.substr(_this,0,byte_pos);
			return $r;
		}(this)));
		var path = document.uri.fsPath;
		return new Promise(function(resolve) {
			var make_request = function() {
				_g.server.request(path,byte_pos,function(items) {
					resolve(items);
				});
			};
			var isDirty = document.isDirty;
			var client = _g.server.client;
			var doRequest = function() {
				if(_g.server.isPatchAvailable) make_request(); else if(isDirty && _g.server.isServerAvailable) document.save().then(make_request); else make_request();
			};
			if(!_g.server.isServerAvailable) {
				var hs = _g.server.make_client();
				var cl = hs.cmdLine;
				var patcher = cl.beginPatch(path);
				if(isDirty) patcher["delete"](0,-1).insert(0,document.getText()); else patcher.remove();
				_g.server.isPatchAvailable = false;
				cl.version();
				hs.sendAll(function(s,message,err) {
					var isPatchAvailable = false;
					var isServerAvailable = true;
					if(err != null) isServerAvailable = false; else {
						_g.server.isServerAvailable = true;
						if(message.hasError) isPatchAvailable = haxe_HaxeClient.isOptionExists("--patch",message.stderr[0]); else isPatchAvailable = true;
					}
					_g.server.isServerAvailable = err == null;
					_g.server.isPatchAvailable = isPatchAvailable;
					doRequest();
				});
			} else doRequest();
		});
	}
	,resolveCompletionItem: function(item,cancelToken) {
		return item;
	}
};
var ChildProcess = require("child_process");
var CompletionServer = function(proj_dir) {
	var _g = this;
	this.proj_dir = proj_dir;
	this.host = "127.0.0.1";
	this.port = 6000;
	this.isServerAvailable = false;
	this.isPatchAvailable = false;
	this.client = new haxe_HaxeClient(this.host,this.port);
	this.client.isPatchAvailable(function(data) {
		_g.isPatchAvailable = data.isOptionAvailable;
		_g.isServerAvailable = data.isServerAvailable;
	});
	var exec = ChildProcess.exec;
	var restart = null;
	restart = function() {
		Vscode.window.showInformationMessage("Starting haxe completion server...");
		exec("haxe --wait " + _g.port,restart);
	};
};
CompletionServer.__name__ = true;
CompletionServer.prototype = {
	make_client: function() {
		return new haxe_HaxeClient(this.host,this.port);
	}
	,parse_items: function(data) {
		var rtn = [];
		var data_str = data.stderr.join("\n");
		
                  // Hack hack hack
                  var items = data_str.split("<i n=");
                  for (var i=0; i<items.length; i++) {
                    var item = items[i];
                    if (item.indexOf("\"")==0) {
                      var name = item.match(/"(.*?)"/)[1];
                      var type = item.match(/<t>(.*?)<\/t>/)[1];
                      type = type.replace(/&gt;/g, ">");
                      type = type.replace(/&lt;/g, "<");
                      //Vscode.window.showInformationMessage(name+" : "+type);
                      var ci = new Vscode.CompletionItem(name);
                      ci.detail = type;
                      if (type.indexOf("->")>=0) {
                        ci.kind = Vscode.CompletionItemKind.Method;
                      } else {
                        ci.kind = Vscode.CompletionItemKind.Property;
                      }
                      rtn.push(ci);
                    }
                  }
     ;
		return rtn;
	}
	,request: function(file,byte_pos,callback) {
		var _g = this;
		var hxml_file = "build.hxml";
		var dir = this.proj_dir;
		var cl = this.client.cmdLine;
		cl.cwd(dir).custom(" " + hxml_file).display(file,byte_pos,haxe_DisplayMode.Default);
		this.client.sendAll(function(s,message,err) {
			if(err != null) {
				_g.isServerAvailable = false;
				Vscode.window.showErrorMessage(err.message);
				callback([]);
			} else {
				_g.isServerAvailable = true;
				callback(_g.parse_items(message));
			}
		});
	}
};
Math.__name__ = true;
var Socket = function() {
	this.s = new js_node_net_Socket();
	this.reset();
};
Socket.__name__ = true;
Socket.prototype = {
	reset: function() {
		this.datas = [];
		this.isConnected = false;
		this.isClosed = false;
		this.error = null;
	}
	,onConnect: function(callback) {
		if(callback != null) callback(this);
	}
	,onError: function(err,callback) {
		if(callback != null) callback(this,err);
	}
	,onData: function(data,callback) {
		data = data.toString();
		this.datas.push(data);
		if(callback != null) callback(this,data);
	}
	,onClose: function(callback) {
		this.isConnected = false;
		this.isClosed = true;
		if(callback != null) callback(this);
	}
	,connect: function(host,port,onConnect,onData,onError,onClose) {
		var _g = this;
		this.error = null;
		this.s.on("error",function(err) {
			_g.error = err;
			_g.onError(err,onError);
		});
		this.s.on("data",function(data) {
			_g.onData(data,onData);
		});
		this.s.on("close",function() {
			_g.onClose(onClose);
		});
		this.s.connect(port,host,function() {
			_g.isConnected = true;
			_g.onConnect(onConnect);
		});
	}
	,write: function(text) {
		return this.s.write(text);
	}
	,readAll: function() {
		return this.s.read();
	}
};
var Tool = function() { };
Tool.__name__ = true;
Tool.displayAsInfo = function(s) {
	Vscode.window.showInformationMessage(s);
};
Tool.displayAsError = function(s) {
	Vscode.window.showErrorMessage(s);
};
Tool.displayAsWarning = function(s) {
	Vscode.window.showWarningMessage(s);
};
Tool.byteLength = function(str) {
	return js_node_buffer_Buffer.byteLength(str);
};
var Vscode = require("vscode");
var haxe_HaxeClient = function(host,port) {
	this.host = host;
	this.port = port;
	this.cmdLine = new haxe_HaxeCmdLine();
	this.clear();
};
haxe_HaxeClient.__name__ = true;
haxe_HaxeClient.isOptionExists = function(optionName,data) {
	var re = new EReg("unknown option '" + optionName + "'","");
	return !re.match(data);
};
haxe_HaxeClient.prototype = {
	clear: function() {
		this.cmdLine.clear();
	}
	,sendAll: function(onClose) {
		var _g = this;
		this.cmdLine.endPatch();
		var s = new Socket();
		s.connect(this.host,this.port,$bind(this,this._onConnect),null,null,function(s1) {
			_g.clear();
			var stdout = [];
			var stderr = [];
			var hasError = false;
			var nl = "\n";
			var _g1 = 0;
			var _g2 = s1.datas.join("").split(nl);
			while(_g1 < _g2.length) {
				var line = _g2[_g1];
				++_g1;
				var _g3 = HxOverrides.cca(line,0);
				if(_g3 != null) switch(_g3) {
				case 1:
					stdout.push(HxOverrides.substr(line,1,null).split("\x01").join(nl));
					break;
				case 2:
					hasError = true;
					break;
				default:
					stderr.push(line);
				} else stderr.push(line);
			}
			if(onClose != null) onClose(s1,{ stdout : stdout, stderr : stderr, hasError : hasError},s1.error);
		});
		return s;
	}
	,_onConnect: function(s) {
		var _g = 0;
		var _g1 = this.cmdLine.cmds;
		while(_g < _g1.length) {
			var cmd = _g1[_g];
			++_g;
			s.write(cmd);
		}
		s.write("\x00");
	}
	,isPatchAvailable: function(onData) {
		var _g = this;
		this.cmdLine.save();
		this.cmdLine.beginPatch("~.hx").remove();
		this.sendAll(function(s,message,error) {
			_g.cmdLine.restore();
			var isServerAvailable = true;
			var isPatchAvailable = false;
			if(error != null) isServerAvailable = false; else isPatchAvailable = !message.hasError;
			onData({ isServerAvailable : isServerAvailable, isOptionAvailable : isPatchAvailable});
		});
	}
};
var haxe_DisplayMode = { __ename__ : true, __constructs__ : ["Default","Position","Usage","Type","TopLevel","Resolve"] };
haxe_DisplayMode.Default = ["Default",0];
haxe_DisplayMode.Default.toString = $estr;
haxe_DisplayMode.Default.__enum__ = haxe_DisplayMode;
haxe_DisplayMode.Position = ["Position",1];
haxe_DisplayMode.Position.toString = $estr;
haxe_DisplayMode.Position.__enum__ = haxe_DisplayMode;
haxe_DisplayMode.Usage = ["Usage",2];
haxe_DisplayMode.Usage.toString = $estr;
haxe_DisplayMode.Usage.__enum__ = haxe_DisplayMode;
haxe_DisplayMode.Type = ["Type",3];
haxe_DisplayMode.Type.toString = $estr;
haxe_DisplayMode.Type.__enum__ = haxe_DisplayMode;
haxe_DisplayMode.TopLevel = ["TopLevel",4];
haxe_DisplayMode.TopLevel.toString = $estr;
haxe_DisplayMode.TopLevel.__enum__ = haxe_DisplayMode;
haxe_DisplayMode.Resolve = function(v) { var $x = ["Resolve",5,v]; $x.__enum__ = haxe_DisplayMode; $x.toString = $estr; return $x; };
var haxe_HaxeCmdLine = function() {
	this.reset();
};
haxe_HaxeCmdLine.__name__ = true;
haxe_HaxeCmdLine.prototype = {
	clear: function() {
		this.cmds = [];
		this.patcher = null;
	}
	,reset: function() {
		this.stack = [];
		this.clear();
	}
	,cwd: function(dir) {
		this.cmds.push("--cwd " + dir + "\n");
		return this;
	}
	,verbose: function() {
		this.cmds.push("-v\n");
		return this;
	}
	,version: function() {
		this.cmds.push("-version\n");
		return this;
	}
	,wait: function(port) {
		this.cmds.push("--wait " + port + "\n");
		return this;
	}
	,display: function(fileName,pos,mode) {
		var dm;
		switch(mode[1]) {
		case 0:
			dm = "";
			break;
		case 1:
			dm = "@position";
			break;
		case 2:
			dm = "@usage";
			break;
		case 3:
			dm = "@position";
			break;
		case 4:
			dm = "@toplevel";
			break;
		case 5:
			var v = mode[2];
			dm = "@resolve@" + v;
			break;
		}
		this.cmds.push("--display " + fileName + "@" + pos + dm + "\n");
		return this;
	}
	,custom: function(data) {
		this.cmds.push(data + "\n");
		return this;
	}
	,beginPatch: function(fileName) {
		this.endPatch();
		this.patcher = new haxe_HaxePatcherCmd(fileName);
		return this.patcher;
	}
	,endPatch: function() {
		if(this.patcher != null) {
			this.cmds.push(this.patcher.get_cmd());
			this.patcher = null;
		}
	}
	,save: function() {
		this.stack.push({ cmds : this.cmds, patcher : this.patcher});
		this.clear();
	}
	,restore: function() {
		var i = this.stack.pop();
		this.cmds = i.cmds;
		this.patcher = i.patcher;
	}
};
var haxe_HaxePatcherCmd = function(fileName) {
	this.fileName = fileName;
	this.actions = [];
};
haxe_HaxePatcherCmd.__name__ = true;
haxe_HaxePatcherCmd.$name = function() {
	return "--patch";
};
haxe_HaxePatcherCmd.prototype = {
	reset: function() {
		this.actions = [];
		return this;
	}
	,remove: function() {
		this.actions.push("x\x01");
		return this;
	}
	,'delete': function(pos,len,unit) {
		if(unit == null) unit = "b";
		this.actions.push("" + unit + "-" + pos + ":" + len + "\x01");
		return this;
	}
	,insert: function(pos,text,unit) {
		if(unit == null) unit = "b";
		this.actions.push("" + unit + "+" + pos + ":" + text + "\x01");
		return this;
	}
	,get_cmd: function() {
		if(this.actions.length == 0) return "";
		var tmp = this.actions.join("@");
		var cmd = "--patch" + ("" + this.fileName + "@" + tmp + "\n");
		return cmd;
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) return "null";
	if(s.length >= 5) return "<...>";
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) t = "object";
	switch(t) {
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) return o[0];
				var str2 = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i1 = _g1++;
					if(i1 != 2) str2 += "," + js_Boot.__string_rec(o[i1],s); else str2 += js_Boot.__string_rec(o[i1],s);
				}
				return str2 + ")";
			}
			var l = o.length;
			var i;
			var str1 = "[";
			s += "\t";
			var _g2 = 0;
			while(_g2 < l) {
				var i2 = _g2++;
				str1 += (i2 > 0?",":"") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") return s2;
		}
		var k = null;
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) str += ", \n";
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "function":
		return "<function>";
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_node_net_Socket = require("net").Socket;
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
})(typeof window != "undefined" ? window : typeof exports != "undefined" ? exports : typeof self != "undefined" ? self : this);
